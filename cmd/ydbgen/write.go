package main

import (
	"bufio"
	"container/list"
	"go/types"
	"log"
	"os"
	"path"
	"sort"
	"strconv"
	"strings"
	"sync"

	"github.com/yandex-cloud/ydb-go-sdk/internal"
)

const GeneratedFileSuffix = "_ydbgen"

var DefaultImportPath = "a.yandex-team.ru/kikimr/public/sdk/go"

func tab(n int) string {
	return strings.Repeat("\t", n)
}

type scope struct {
	vars map[string]bool
}

func (s *scope) has(name string) bool {
	if s.vars == nil {
		return false
	}
	return s.vars[name]
}

func (s *scope) add(name string) {
	if s.vars == nil {
		s.vars = make(map[string]bool)
	}
	if s.vars[name] {
		panic("scope: variable already exists")
	}
	s.vars[name] = true
}

type Generator struct {
	ImportPath string
	Dir        string

	once        sync.Once
	conversions map[string]ConversionTemplate
	seenConv    map[string]bool

	scopes list.List // list<scope>
}

func (g *Generator) enterScope() {
	g.scopes.PushFront(new(scope))
}

func (g *Generator) leaveScope() {
	g.scopes.Remove(g.scopes.Front())
}

func (g *Generator) declare(v string) string {
	var (
		front = g.scopes.Front()
		curr  = front.Value.(*scope)
		x     = -1
	)
search:
	for {
		name := v
		if x >= 0 {
			name += strconv.Itoa(x)
		}
		for el := front; el != nil; el = el.Next() {
			s := el.Value.(*scope)
			if s.has(name) {
				x++
				continue search
			}
		}
		curr.add(name)
		return name
	}
}

func (g *Generator) init() {
	g.once.Do(func() {
		g.conversions = make(map[string]ConversionTemplate)
		g.seenConv = make(map[string]bool)
		if g.ImportPath == "" {
			g.ImportPath = DefaultImportPath
		}
	})
}

type dep struct {
	path  string
	name  string
	ident string
	std   bool
}

func (g *Generator) importDeps(bw *bufio.Writer, deps ...dep) {
	bw.WriteString("import (\n")
	prev := deps[0].std
	for _, dep := range deps {
		if dep.std != prev {
			prev = dep.std
			line(bw)
		}
		line(bw, tab(1), `"`, path.Join(dep.path, dep.name), `"`)
	}
	line(bw, `)`)
	line(bw)

	// Suppress unused imports.
	line(bw, "var (")
	for _, dep := range deps {
		if dep.ident != "" {
			line(bw, tab(1), `_ = `, dep.name, `.`, dep.ident)
		}
	}
	line(bw, ")")
	line(bw)
}

func (g *Generator) fileHeader(bw *bufio.Writer, pkg string) {
	line(bw, `// Code generated by ydbgen; DO NOT EDIT.`)
	line(bw)
	line(bw, `package `, pkg)
	line(bw)
}

func (g *Generator) Generate(pkg Package) error {
	g.init()

	for _, f := range pkg.Files {
		if f.Empty() {
			continue
		}
		var (
			base = path.Base(f.Name)
			ext  = path.Ext(base)
			name = strings.TrimSuffix(base, ext)

			fpath = path.Join(g.Dir, name+GeneratedFileSuffix+ext)
		)
		file, err := os.OpenFile(fpath, os.O_WRONLY|os.O_CREATE|os.O_TRUNC, 0666)
		if err != nil {
			return err
		}
		defer file.Close()

		bw := bufio.NewWriter(file)

		g.fileHeader(bw, pkg.Name)

		g.importDeps(bw,
			dep{
				name:  "strconv",
				ident: "Itoa",
				std:   true,
			},
			dep{
				name:  "ydb",
				path:  g.ImportPath,
				ident: "StringValue",
			},
			dep{
				name:  "table",
				path:  path.Join(g.ImportPath, "ydb"),
				ident: "NewQueryParameters",
			},
		)

		for _, s := range f.Structs {
			if s.Flags&GenScan != 0 {
				g.generateStructScan(bw, s)
			}
			if s.Flags&GenQueryParams != 0 {
				g.generateStructQueryParams(bw, s)
			}
			if s.Flags&GenValue != 0 {
				g.generateStructValue(bw, s)
			}
			if s.Flags&GenType != 0 {
				g.generateStructType(bw, s)
			}
			log.Printf("%s struct", s.Name)
		}
		for _, s := range f.Slices {
			if s.Flags&GenScan != 0 {
				g.generateSliceScan(bw, s)
			}
			if s.Flags&GenType != 0 {
				g.generateSliceType(bw, s)
			}
			if s.Flags&GenValue != 0 {
				g.generateSliceValue(bw, s)
			}
			log.Printf("%s slice", s.Name)
		}
		var templates []string
		for name := range g.conversions {
			if !g.seenConv[name] {
				templates = append(templates, name)
			}
		}
		sort.Slice(templates, func(i, j int) bool {
			return templates[i] < templates[j]
		})
		for _, name := range templates {
			g.conversions[name].Write(bw)
			delete(g.conversions, name)
			g.seenConv[name] = true
		}
		if err := bw.Flush(); err != nil {
			os.Remove(file.Name())
			return err
		}
	}
	return nil
}

func structReceiver(s *Struct) string {
	return strings.ToLower(s.Name[0:1])
}

func sliceReceiver(s *Slice) string {
	return strings.ToLower(s.Name[0:1]) + "s"
}

func sliceItem(s *Slice) string {
	return strings.ToLower(s.Name[0:1])
}

func (g *Generator) generateStructScan(bw *bufio.Writer, s *Struct) {
	g.enterScope()
	defer g.leaveScope()

	var (
		rcvr = g.declare(structReceiver(s))
		res  = g.declare("res")
		err  = g.declare("err")
	)
	code(bw, `func (`, rcvr, ` *`, s.Name+`) `)
	line(bw, `Scan(`, res, ` *table.Result) (`, err, ` error) {`)
	g.writeStructFieldsScan(bw, 1, rcvr, s)
	line(bw, tab(1), `return `, res, `.Err()`)
	line(bw, `}`)
	line(bw)
}

func (g *Generator) generateStructQueryParams(bw *bufio.Writer, s *Struct) {
	g.enterScope()
	defer g.leaveScope()

	var (
		rcvr = g.declare(structReceiver(s))
	)
	code(bw, `func (`, rcvr, ` *`, s.Name+`) `)
	line(bw, `QueryParameters() *table.QueryParameters {`)
	writeField := g.writeStructFieldsGetters(bw, 1, rcvr, s)
	line(bw, tab(1), `return table.NewQueryParameters(`)
	for _, f := range s.Fields {
		code(bw, tab(2))
		code(bw, `table.ValueParam("$`, f.Column, `", `)
		writeField(f)
		line(bw, `),`)
	}
	line(bw, tab(1), ")")
	line(bw, "}")
	line(bw)
}

func (g *Generator) generateStructValue(bw *bufio.Writer, s *Struct) {
	g.enterScope()
	defer g.leaveScope()

	var (
		rcvr = g.declare(structReceiver(s))
		val  = g.declare("val")
	)
	code(bw, `func (`, rcvr, ` *`, s.Name+`) `)
	line(bw, `StructValue() ydb.Value {`)
	g.writeStructValue(bw, 1, rcvr, val+" := ", s)
	code(bw, tab(1), `return `, val)
	line(bw)
	line(bw, `}`)
	line(bw)
}

func (g *Generator) generateStructType(bw *bufio.Writer, s *Struct) {
	g.enterScope()
	defer g.leaveScope()

	var (
		rcvr = g.declare(structReceiver(s))
	)
	code(bw, `func (`, rcvr, ` *`, s.Name+`) `)
	line(bw, `StructType() ydb.Type {`)
	code(bw, tab(1), `return `)
	g.writeStructType(bw, 1, s)
	line(bw)
	line(bw, `}`)
	line(bw)
}

func (g *Generator) generateSliceScan(bw *bufio.Writer, s *Slice) {
	g.enterScope()
	defer g.leaveScope()

	var (
		rcvr = g.declare(sliceReceiver(s))
		res  = g.declare("res")
		err  = g.declare("err")
	)
	code(bw, `func (`, rcvr, ` *`, s.Name+`) `)
	line(bw, `Scan(`, res, ` *table.Result) (`, err, ` error) {`)

	g.enterScope()
	{
		line(bw, tab(1), `for `, res, `.NextRow() {`)
		x := g.declare("x")
		line(bw, tab(2), `var `, x, ` `, s.Struct.Name)
		line(bw)
		g.writeStructFieldsScan(bw, 2, x, s.Struct)
		line(bw, tab(2), `if `, res, `.Err() == nil {`)
		line(bw, tab(3), `*`, rcvr, ` = append(*`, rcvr, `, `, x, `)`)
		line(bw, tab(2), `}`)
		line(bw, tab(1), `}`)
	}
	g.leaveScope()

	line(bw, tab(1), `return `, res, `.Err()`)
	line(bw, `}`)
	line(bw)
}

func (g *Generator) generateSliceValue(bw *bufio.Writer, s *Slice) {
	g.enterScope()
	defer g.leaveScope()

	var (
		rcvr   = g.declare(sliceReceiver(s))
		values = g.declare("values")
	)
	code(bw, `func (`, rcvr, ` `, s.Name+`) `)
	line(bw, `ListValue() ydb.Value {`)
	line(bw, tab(1), values, ` := make([]ydb.Value, len(`, rcvr, `))`)

	g.enterScope()
	{
		var (
			i    = g.declare("i")
			item = g.declare(sliceItem(s))
		)
		line(bw, tab(1), `for `, i, `, `, item, ` := range `, rcvr, ` {`)
		g.writeStructValue(bw, 2, item, values+"["+i+"] = ", s.Struct)
		line(bw, tab(1), `}`)
	}
	g.leaveScope()

	line(bw, tab(1), `if len(`, values, `) == 0 {`)
	line(bw, tab(2), `return ydb.ZeroValue(`)
	code(bw, tab(3), `ydb.List(`)
	g.writeStructType(bw, 3, s.Struct)
	line(bw, `),`)
	line(bw, tab(2), `)`)
	line(bw, tab(1), `}`)
	line(bw, tab(1), `return ydb.ListValue(`, values, `...)`)
	line(bw, `}`)
	line(bw)
}

func (g *Generator) generateSliceType(bw *bufio.Writer, s *Slice) {
	code(bw, `func (`, s.Name+`) `)
	line(bw, `ListType() ydb.Type {`)
	code(bw, tab(1), `return ydb.List(`)
	g.writeStructType(bw, 1, s.Struct)
	line(bw, `)`)
	line(bw, `}`)
	line(bw)
}

type Context struct {
	Rcvr      string
	In        string
	Out       string
	Predicate string
	Field     *Field
	Depth     int
}

type FieldFace interface {
	Get(*bufio.Writer, Context)
	Set(*bufio.Writer, Context)
}

type DefaultFieldFace struct{}

func (DefaultFieldFace) Get(bw *bufio.Writer, c Context) {
	code(bw, tab(c.Depth), c.Out, `, `, c.Predicate, ` := `)
	line(bw, c.Rcvr, `.`, c.Field.Name, `.Get()`)
}
func (DefaultFieldFace) Set(bw *bufio.Writer, c Context) {
	line(bw, tab(c.Depth), c.Rcvr, `.`, c.Field.Name, `.Set(`, c.In, `)`)
}

type TimeFieldFace struct{}

func (TimeFieldFace) Get(bw *bufio.Writer, c Context) {
	v := c.Rcvr + "." + c.Field.Name
	yname := ydbTypeName(c.Field.Primitive)
	line(bw, tab(c.Depth), `var `, c.Out, ` `, c.Field.BaseType.String())
	line(bw, tab(c.Depth), c.Predicate, ` := !`, v, `.IsZero()`)
	line(bw, tab(c.Depth), `if `, c.Predicate, ` {`)
	line(bw, tab(c.Depth+1), c.Out, ` = ydb.Time(`, v, `).`, yname, `()`)
	line(bw, tab(c.Depth), `}`)
}
func (TimeFieldFace) Set(bw *bufio.Writer, c Context) {
	v := c.Rcvr + "." + c.Field.Name
	y := ydbTypeName(c.Field.Primitive)
	code(bw, tab(c.Depth), `err := `)
	line(bw, `(*ydb.Time)(&`, v, `).From`, y, `(`, c.In, `)`)
	line(bw, tab(c.Depth), `if err != nil {`)
	line(bw, tab(c.Depth+1), `panic("ydbgen: date type conversion failed: " + err.Error())`)
	line(bw, tab(c.Depth), `}`)
}

func (g *Generator) writeFieldGetter(bw *bufio.Writer, depth int, rcvr string, f *Field) {
	yname := ydbTypeName(f.Primitive)
	var (
		val = g.declare(f.Name + "Value")
	)
	line(bw, tab(depth), `var `, val, ` ydb.Value`)
	line(bw, tab(depth), `{`)
	g.enterScope()
	{
		var (
			x  = g.declare("x")
			ok = g.declare("ok")
		)
		f.Face.Get(bw, Context{
			Rcvr:      rcvr,
			Out:       x,
			Predicate: ok,
			Field:     f,
			Depth:     depth + 1,
		})
		line(bw, tab(depth+1), `if `, ok, ` {`)
		code(bw, tab(depth+2), val, ` = `)
		if f.Optional {
			code(bw, `ydb.OptionalValue(`)
		}
		code(bw, `ydb.`, yname, `Value(`)
		g.convert(bw, f.Conv, x, f.Type, f.BaseType)
		code(bw, `)`)
		if f.Optional {
			code(bw, `)`)
		}
		line(bw)
		line(bw, tab(depth+1), `} else {`)
		if f.Optional {
			code(bw, tab(depth+2), val, ` = `)
			line(bw, `ydb.NullValue(ydb.Type`, yname, `)`)
		} else {
			line(bw, tab(depth+2), `panic("ydbgen: no value for non-optional field \"`, f.Name, `\"")`)
		}
		line(bw, tab(depth+1), `}`)
	}
	g.leaveScope()
	line(bw, tab(depth), `}`)
}

func (g *Generator) writeStructFieldsGetters(bw *bufio.Writer, depth int, rcvr string, s *Struct) (write func(*Field)) {
	faced := map[string]bool{}
	for _, f := range s.Fields {
		if f.Face == nil {
			continue
		}
		faced[f.Name] = true
		g.writeFieldGetter(bw, depth, rcvr, f)
	}
	return func(f *Field) {
		yname := ydbTypeName(f.Primitive)
		if faced[f.Name] {
			code(bw, f.Name, `Value`)
		} else {
			if f.Optional {
				code(bw, `ydb.OptionalValue(`)
			}
			code(bw, `ydb.`, yname)
			code(bw, `Value(`)
			val := rcvr + "." + f.Name
			g.convert(bw, f.Conv, val, f.Type, f.BaseType)
			code(bw, `)`)
			if f.Optional {
				code(bw, `)`)
			}
		}
	}
}

func (g *Generator) writeStructValue(bw *bufio.Writer, depth int, rcvr, assign string, s *Struct) {
	writeField := g.writeStructFieldsGetters(bw, depth, rcvr, s)
	line(bw, tab(depth), assign, `ydb.StructValue(`)
	for _, f := range s.Fields {
		code(bw, tab(depth+1))
		code(bw, `ydb.StructFieldValue("`, f.Column, `", `)
		writeField(f)
		line(bw, `),`)
	}
	line(bw, tab(depth), `)`)
}

func (g *Generator) writeStructType(bw *bufio.Writer, depth int, s *Struct) {
	line(bw, `ydb.Struct(`)
	for _, f := range s.Fields {
		code(bw, tab(depth+1))
		code(bw, `ydb.StructField("`, f.Column, `", `)
		if f.Optional {
			code(bw, `ydb.Optional(`)
		}
		code(bw, `ydb.Type`, ydbTypeName(f.Primitive))
		code(bw, `)`)
		if f.Optional {
			code(bw, `)`)
		}
		line(bw, `,`)
	}
	code(bw, tab(depth), `)`)
}

func (g *Generator) writeStructFieldsScan(bw *bufio.Writer, depth int, rcvr string, s *Struct) {
	for _, f := range s.Fields {
		if s.SeekMode&SeekPosition != 0 {
			line(bw, tab(depth), `res.NextItem()`)
		} else {
			line(bw, tab(depth), `res.SeekItem("`, f.Column, `")`)
		}

		yname := ydbTypeName(f.Primitive)

		if face := f.Face; face != nil {
			if f.Optional {
				line(bw, tab(depth), `res.Unwrap()`)
				line(bw, tab(depth), `if !res.IsNull() {`)
			} else {
				line(bw, tab(depth), `{`)
			}
			g.enterScope()
			{
				var (
					x = g.declare("x")
				)
				code(bw, tab(depth+1), x, ` := `)
				val := "res." + yname + "()"
				g.convert(bw, f.Conv, val, f.BaseType, f.Type)
				line(bw)
				face.Set(bw, Context{
					Rcvr:  rcvr,
					Field: f,
					In:    x,
					Depth: depth + 1,
				})
			}
			g.leaveScope()
			line(bw, tab(depth), `}`)
		} else {
			code(bw, tab(depth), rcvr, ".", f.Name, " = ")
			val := "res."
			if f.Optional {
				val += "O"
			}
			val += yname + "()"
			g.convert(bw, f.Conv, val, f.BaseType, f.Type)
			line(bw)
		}

		line(bw)
	}
}

func sizeof(t types.Type) int {
	b := t.(*types.Basic)
	switch b.Kind() {
	case types.Int, types.Uint:
		return 0
	case types.Int8, types.Uint8:
		return 8
	case types.Int16, types.Uint16:
		return 16
	case types.Int32, types.Uint32:
		return 32
	case types.Int64, types.Uint64:
		return 64
	}
	return -1
}

func isDigit(c byte) bool {
	return '0' <= c && c <= '9'
}

func typeShortName(t types.Type) string {
	const upper = ^byte('a' - 'A')
	var (
		s   = t.String()
		n   = len(s)
		bts = make([]byte, 1, 3)
	)
	bts[0] = s[0] & upper
	for i := n - 2; i < n; i++ {
		if isDigit(s[i]) {
			bts = append(bts, s[i])
		}
	}
	return string(bts)
}

func (g *Generator) convert(bw *bufio.Writer, mode ConvMode, name string, src, dst types.Type) {
	if src == dst {
		code(bw, name)
		return
	}
	var conv string
	if mode == ConvAssert && !isSafeConversion(src, dst) {
		conv = g.conversionFunc(src, dst)
	} else {
		conv = dst.String()
	}
	code(bw, conv, `(`, name, `)`)
}

func (g *Generator) conversionFunc(t1, t2 types.Type) string {
	if _, _, bothBasic := basic(t1, t2); !bothBasic {
		return t2.String()
	}
	name := strings.Join([]string{
		"ydbConv",
		typeShortName(t1),
		"To",
		typeShortName(t2),
	}, "")
	if _, ok := g.conversions[name]; !ok {
		g.conversions[name] = ConversionTemplate{
			Name: name,
			Type: [2]types.Type{t1, t2},
		}
	}
	return name
}

type ConversionTemplate struct {
	Name string
	Type [2]types.Type
}

func (t ConversionTemplate) Write(bw *bufio.Writer) {
	var (
		IntInt   = [2]bool{false, false}
		UintUint = [2]bool{true, true}
		IntUint  = [2]bool{false, true}
		UintInt  = [2]bool{true, false}
	)

	code(bw, `func `, t.Name, `(`)
	code(bw, `x `, t.Type[0].String(), `)`)
	line(bw, ` `, t.Type[1].String(), ` { `)
	defer func() {
		line(bw, tab(1), `return `, t.Type[1].String(), `(x)`)
		line(bw, `}`)
		line(bw)
	}()
	b0, b1, ok := basic(t.Type[0], t.Type[1])
	if !ok {
		panic("ydbgen: internal: not a basic type for conversion")
	}
	var (
		i0 = b0.Info()
		i1 = b1.Info()
		s0 = sizeof(b0)
		s1 = sizeof(b1)
	)
	if i0&types.IsInteger == 0 || i1&types.IsInteger == 0 {
		panic("ydbgen: internal: not an integer type for conversion")
	}
	signconv := [2]bool{
		i0&types.IsUnsigned != 0,
		i1&types.IsUnsigned != 0,
	}
	if signconv == IntUint {
		line(bw, tab(1), `if x < 0 {`)
		code(bw, tab(2), `panic("ydbgen: convassert: conversion of negative `)
		line(bw, b0.String(), ` to `, b1.String(), `")`)
		line(bw, tab(1), `}`)
	}
	if s0 <= s1 && signconv != UintInt {
		return
	}

	line(bw, tab(1), `const (`)
	switch b1.Kind() {
	case types.Int, types.Uint:
		line(bw, tab(2), `bits = 32 << (^uint(0) >> 63)`)
	default:
		line(bw, tab(2), `bits = `, strconv.Itoa(s1))
	}
	code(bw, tab(2), `mask = (1 << (bits`)
	if signconv == UintInt || signconv == IntInt {
		code(bw, ` - 1))`)
	} else {
		code(bw, `))`)
	}
	line(bw, ` - 1`)
	line(bw, tab(1), `)`)

	switch signconv {
	case IntInt, IntUint:
		abs(bw, 1, "x", "abs")
	case UintInt, UintUint:
		line(bw, tab(1), `abs := uint64(x)`)
	}
	line(bw, tab(1), `if abs&mask != abs {`)
	line(bw, tab(2), `panic(`)
	code(bw, tab(3), `"ydbgen: convassert: " + `)
	format(bw, i0, 2, "x")
	line(bw, ` +`)
	code(bw, tab(4), `" (type `, b0.String(), `)`)
	line(bw, ` overflows `, b1.String(), `",`)
	line(bw, tab(2), `)`)
	line(bw, tab(1), `}`)
}

func abs(bw *bufio.Writer, depth int, in, out string) {
	line(bw, tab(depth), `var `, out, ` uint64`)
	line(bw, tab(depth), `{`)
	line(bw, tab(depth+1), `v := int64(`, in, `)`)
	line(bw, tab(depth+1), `m := v >> 63`)
	line(bw, tab(depth+1), out, ` = uint64(v ^ m - m)`)
	line(bw, tab(depth), `}`)
}

func format(bw *bufio.Writer, info types.BasicInfo, depth int, in string) {
	var (
		t string
		w string
	)
	if info&types.IsUnsigned != 0 {
		t = "Uint"
		w = "uint64"
	} else {
		t = "Int"
		w = "int64"
	}
	code(bw, `strconv.Format`)
	code(bw, t, `(`, w, `(`, in, `), 10)`)
}

func line(bw *bufio.Writer, args ...string) {
	code(bw, args...)
	bw.WriteByte('\n')
}

func code(bw *bufio.Writer, args ...string) {
	for _, arg := range args {
		bw.WriteString(arg)
	}
}

func ydbTypeName(t internal.PrimitiveType) string {
	switch t {
	case internal.TypeBool:
	case internal.TypeInt8:
	case internal.TypeUint8:
	case internal.TypeInt16:
	case internal.TypeUint16:
	case internal.TypeInt32:
	case internal.TypeUint32:
	case internal.TypeInt64:
	case internal.TypeUint64:
	case internal.TypeFloat:
	case internal.TypeDouble:
	case internal.TypeDate:
	case internal.TypeDatetime:
	case internal.TypeTimestamp:
	case internal.TypeInterval:
	case internal.TypeTzDate:
	case internal.TypeTzDatetime:
	case internal.TypeTzTimestamp:
	case internal.TypeString:

	case internal.TypeUTF8:
		return "UTF8"
	case internal.TypeYSON:
		return "YSON"
	case internal.TypeJSON:
		return "JSON"
	case internal.TypeUUID:
		return "UUID"
	}
	return t.String()
}
