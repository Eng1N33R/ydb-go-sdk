package main

import (
	"bufio"
	"go/types"
	"os"
	"path"
	"sort"
	"strconv"
	"strings"
	"sync"

	"github.com/yandex-cloud/ydb-go-sdk/internal"
)

const GeneratedFileSuffix = "_ydbgen"

var DefaultImportDir = "a.yandex-team.ru/kikimr/public/sdk/go"

func tab(n int) string {
	return strings.Repeat("\t", n)
}

type Generator struct {
	ImportDir string

	once        sync.Once
	conversions map[string]ConversionTemplate
	seenConv    map[string]bool
}

func (g *Generator) init() {
	g.once.Do(func() {
		g.conversions = make(map[string]ConversionTemplate)
		g.seenConv = make(map[string]bool)
		if g.ImportDir == "" {
			g.ImportDir = DefaultImportDir
		}
	})
}

type dep struct {
	path  string
	name  string
	ident string
	std   bool
}

func (g *Generator) importDeps(bw *bufio.Writer, deps ...dep) {
	bw.WriteString("import (\n")
	prev := deps[0].std
	for _, dep := range deps {
		if dep.std != prev {
			prev = dep.std
			line(bw)
		}
		line(bw, tab(1), `"`, path.Join(dep.path, dep.name), `"`)
	}
	line(bw, `)`)
	line(bw)

	// Suppress unused imports.
	line(bw, "var (")
	for _, dep := range deps {
		if dep.ident != "" {
			line(bw, tab(1), `_ `, dep.name, `.`, dep.ident)
		}
	}
	line(bw, ")")
	line(bw)
}

func (g *Generator) fileHeader(bw *bufio.Writer, pkg string) {
	line(bw, `// Code generated by ydbgen; DO NOT EDIT.`)
	line(bw)
	line(bw, `package `, pkg)
	line(bw)
}

func (g *Generator) Generate(pkg Package) error {
	g.init()

	for _, f := range pkg.Files {
		if f.Empty() {
			continue
		}
		var (
			base = path.Base(f.Name)
			dir  = strings.TrimSuffix(f.Name, base)
			ext  = path.Ext(base)
			name = strings.TrimSuffix(base, ext)

			fpath = path.Join(dir, name+GeneratedFileSuffix+ext)
		)
		file, err := os.OpenFile(fpath, os.O_WRONLY|os.O_CREATE|os.O_TRUNC, 0666)
		if err != nil {
			return err
		}
		defer file.Close()

		bw := bufio.NewWriter(file)

		g.fileHeader(bw, pkg.Name)

		g.importDeps(bw,
			dep{
				name:  "strconv",
				ident: "Itoa",
				std:   true,
			},
			dep{
				name:  "ydb",
				path:  g.ImportDir,
				ident: "Value",
			},
			dep{
				name:  "table",
				path:  path.Join(g.ImportDir, "ydb"),
				ident: "QueryParameters",
			},
		)

		for _, s := range f.Slices {
			g.generateSliceScan(bw, s)
		}
		for _, s := range f.Structs {
			if s.Flags&GenScan != 0 {
				g.generateStructScan(bw, s)
			}
			if s.Flags&GenQueryParams != 0 {
				g.generateStructQueryParams(bw, s)
			}
			if s.Flags&GenContainer != 0 {
				g.generateStructContainer(bw, s)
			}
		}
		var templates []string
		for name := range g.conversions {
			if !g.seenConv[name] {
				templates = append(templates, name)
			}
		}
		sort.Slice(templates, func(i, j int) bool {
			return templates[i] < templates[j]
		})
		for _, name := range templates {
			g.conversions[name].Write(bw)
			delete(g.conversions, name)
			g.seenConv[name] = true
		}
		if err := bw.Flush(); err != nil {
			os.Remove(file.Name())
			return err
		}
	}
	return nil
}

func (g *Generator) structReceiver(s *Struct) string {
	return strings.ToLower(s.Name[0:1])
}

func (g *Generator) sliceReceiver(s *Slice) string {
	return strings.ToLower(s.Name[0:1]) + "s"
}

func (g *Generator) generateStructScan(bw *bufio.Writer, s *Struct) {
	rcvr := g.structReceiver(s)
	code(bw, "func (", rcvr, " *", s.Name+") ")
	line(bw, "Scan(res *table.Result) (err error) {")
	g.generateStructFieldsScan(bw, 1, rcvr, s)
	line(bw, tab(1), "return res.Err()")
	line(bw, "}")
	line(bw)
}

func (g *Generator) generateStructQueryParams(bw *bufio.Writer, s *Struct) {
	rcvr := g.structReceiver(s)
	code(bw, `func (`, rcvr, ` *`, s.Name+`) `)
	line(bw, `QueryParameters() *table.QueryParameters {`)
	line(bw, tab(1), `return table.NewQueryParameters(`)
	for _, f := range s.Fields {
		code(bw, tab(2))
		code(bw, `table.ValueParam("$`, f.Column, `", `)
		code(bw, `ydb.`, ydbTypeName(f.Primitive))
		code(bw, `Value(`)
		g.convert(bw, f.Conv, rcvr+"."+f.Name, f.Type, f.BaseType)
		code(bw, `)),`)

		line(bw)
	}
	line(bw, tab(1), ")")
	line(bw, "}")
	line(bw)
}

func (g *Generator) generateStructContainer(bw *bufio.Writer, s *Struct) {
	rcvr := g.structReceiver(s)
	code(bw, `func (`, rcvr, ` *`, s.Name+`) `)
	line(bw, `StructValue() ydb.Value {`)
	line(bw, tab(1), `return ydb.StructValue(`)
	for _, f := range s.Fields {
		code(bw, tab(2))
		code(bw, `ydb.StructFieldValue("`, f.Column, `", `)
		code(bw, `ydb.`, ydbTypeName(f.Primitive))
		code(bw, `Value(`)
		g.convert(bw, f.Conv, rcvr+"."+f.Name, f.Type, f.BaseType)
		code(bw, `)),`)

		line(bw)
	}
	line(bw, tab(1), ")")
	line(bw, "}")
	line(bw)
}

func (g *Generator) generateSliceScan(bw *bufio.Writer, s *Slice) {
	rcvr := g.sliceReceiver(s)
	code(bw, "func (", rcvr, " *", s.Name+") ")
	line(bw, "Scan(res *table.Result) (err error) {")
	line(bw, tab(1), "for res.NextRow() {")
	line(bw, tab(2), "var x ", s.Struct.Name)
	line(bw)
	g.generateStructFieldsScan(bw, 2, "x", s.Struct)
	line(bw, tab(2), "*", rcvr, " = append(*", rcvr, ", x)")
	line(bw, tab(1), "}")
	line(bw, tab(1), "return res.Err()")
	line(bw, "}")
	line(bw)
}

func (g *Generator) generateStructFieldsScan(bw *bufio.Writer, depth int, rcvr string, s *Struct) {
	for _, f := range s.Fields {
		if s.SeekMode&SeekPosition != 0 {
			line(bw, tab(depth), `res.NextItem()`)
		} else {
			line(bw, tab(depth), `res.SeekItem("`, f.Column, `")`)
		}

		code(bw, tab(depth), rcvr, ".", f.Name, " = ")
		val := "res." + getter(f.Primitive) + "()"
		g.convert(bw, f.Conv, val, f.BaseType, f.Type)

		line(bw)
		line(bw)
	}
}

func sizeof(t types.Type) int {
	b := t.(*types.Basic)
	switch b.Kind() {
	case types.Int, types.Uint:
		return 0
	case types.Int8, types.Uint8:
		return 8
	case types.Int16, types.Uint16:
		return 16
	case types.Int32, types.Uint32:
		return 32
	case types.Int64, types.Uint64:
		return 64
	}
	return -1
}

func isDigit(c byte) bool {
	return '0' <= c && c <= '9'
}

func typeShortName(t types.Type) string {
	const upper = ^byte('a' - 'A')
	var (
		s   = t.String()
		n   = len(s)
		bts = make([]byte, 1, 3)
	)
	bts[0] = s[0] & upper
	for i := n - 2; i < n; i++ {
		if isDigit(s[i]) {
			bts = append(bts, s[i])
		}
	}
	return string(bts)
}

func (g *Generator) convert(bw *bufio.Writer, mode ConvMode, name string, src, dst types.Type) {
	if src == dst {
		code(bw, name)
		return
	}
	var conv string
	if mode == ConvAssert && !isSafeConversion(src, dst) {
		conv = g.conversionFunc(src, dst)
	} else {
		conv = dst.String()
	}
	code(bw, conv, `(`, name, `)`)
}

func (g *Generator) conversionFunc(t1, t2 types.Type) string {
	if _, _, bothBasic := basic(t1, t2); !bothBasic {
		return t2.String()
	}
	name := strings.Join([]string{
		"ydbConv",
		typeShortName(t1),
		"To",
		typeShortName(t2),
	}, "")
	if _, ok := g.conversions[name]; !ok {
		g.conversions[name] = ConversionTemplate{
			Name: name,
			Type: [2]types.Type{t1, t2},
		}
	}
	return name
}

type ConversionTemplate struct {
	Name string
	Type [2]types.Type
}

func (t ConversionTemplate) Write(bw *bufio.Writer) {
	var (
		IntInt   = [2]bool{false, false}
		UintUint = [2]bool{true, true}
		IntUint  = [2]bool{false, true}
		UintInt  = [2]bool{true, false}
	)

	code(bw, `func `, t.Name, `(`)
	code(bw, `x `, t.Type[0].String(), `)`)
	line(bw, ` `, t.Type[1].String(), ` { `)
	defer func() {
		line(bw, tab(1), `return `, t.Type[1].String(), `(x)`)
		line(bw, `}`)
		line(bw)
	}()
	///s0, s1 := t.sizes()
	b0, b1, ok := basic(t.Type[0], t.Type[1])
	if !ok {
		panic("ydbgen: internal: not a basic type for conversion")
	}
	var (
		i0 = b0.Info()
		i1 = b1.Info()
		s0 = sizeof(b0)
		s1 = sizeof(b1)
	)
	if i0&types.IsInteger == 0 || i1&types.IsInteger == 0 {
		panic("ydbgen: internal: not an integer type for conversion")
	}
	signconv := [2]bool{
		i0&types.IsUnsigned != 0,
		i1&types.IsUnsigned != 0,
	}
	if signconv == IntUint {
		line(bw, tab(1), `if x < 0 {`)
		code(bw, tab(2), `panic("ydbgen: convassert: conversion of negative `)
		line(bw, b0.String(), ` to `, b1.String(), `")`)
		line(bw, tab(1), `}`)
	}
	if s0 <= s1 && signconv != UintInt {
		return
	}

	line(bw, tab(1), `const (`)
	switch b1.Kind() {
	case types.Int, types.Uint:
		line(bw, tab(2), `bits = 32 << (^uint(0) >> 63)`)
	default:
		line(bw, tab(2), `bits = `, strconv.Itoa(s1))
	}
	code(bw, tab(2), `mask = (1 << (bits`)
	if signconv == UintInt || signconv == IntInt {
		code(bw, ` - 1))`)
	} else {
		code(bw, `))`)
	}
	line(bw, ` - 1`)
	line(bw, tab(1), `)`)

	switch signconv {
	case IntInt, IntUint:
		abs(bw, 1, "x", "abs")
	case UintInt, UintUint:
		line(bw, tab(1), `abs := uint64(x)`)
	}
	line(bw, tab(1), `if abs&mask != abs {`)
	format(bw, i0, 2, "x", "str")
	line(bw, tab(2), `panic(`)
	code(bw, tab(3), `"ydbgen: convassert: "`)
	code(bw, ` + str + " (type `, b0.String(), `)`)
	line(bw, ` overflows `, b1.String(), `",`)
	line(bw, tab(2), `)`)
	line(bw, tab(1), `}`)
}

func abs(bw *bufio.Writer, depth int, in, out string) {
	line(bw, tab(depth), `var `, out, ` uint64`)
	line(bw, tab(depth), `{`)
	line(bw, tab(depth+1), `v := int64(`, in, `)`)
	line(bw, tab(depth+1), `m := v >> 63`)
	line(bw, tab(depth+1), out, ` = uint64(v ^ m - m)`)
	line(bw, tab(depth), `}`)
}

func format(bw *bufio.Writer, info types.BasicInfo, depth int, in, out string) {
	var (
		t string
		w string
	)
	if info&types.IsUnsigned != 0 {
		t = "Uint"
		w = "uint64"
	} else {
		t = "Int"
		w = "int64"
	}
	line(bw, tab(depth), `var `, out, ` string`)
	line(bw, tab(depth), `{`)
	code(bw, tab(depth+1), `s, err := strconv.Format`)
	line(bw, t, `(`, w, `(`, in, `), 10)`)
	line(bw, tab(depth+1), `if err != nil {`)
	line(bw, tab(depth+2), `panic("ydbgen: internal: format error")`)
	line(bw, tab(depth+1), `}`)
	line(bw, tab(depth+1), out, ` = s`)
	line(bw, tab(depth), `}`)
}

func line(bw *bufio.Writer, args ...string) {
	code(bw, args...)
	bw.WriteByte('\n')
}

func code(bw *bufio.Writer, args ...string) {
	for _, arg := range args {
		bw.WriteString(arg)
	}
}

func ydbTypeName(t internal.PrimitiveType) string {
	switch t {
	case internal.TypeBool:
	case internal.TypeInt8:
	case internal.TypeUint8:
	case internal.TypeInt16:
	case internal.TypeUint16:
	case internal.TypeInt32:
	case internal.TypeUint32:
	case internal.TypeInt64:
	case internal.TypeUint64:
	case internal.TypeFloat:
	case internal.TypeDouble:
	case internal.TypeDate:
	case internal.TypeDatetime:
	case internal.TypeTimestamp:
	case internal.TypeInterval:
	case internal.TypeTzDate:
	case internal.TypeTzDatetime:
	case internal.TypeTzTimestamp:
	case internal.TypeString:

	case internal.TypeUTF8:
		return "UTF8"
	case internal.TypeYSON:
		return "YSON"
	case internal.TypeJSON:
		return "JSON"
	case internal.TypeUUID:
		return "UUID"
	}
	return t.String()
}

func getter(t internal.PrimitiveType) string {
	return "O" + ydbTypeName(t)
}
