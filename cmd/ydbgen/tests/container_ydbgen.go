// Code generated by ydbgen; DO NOT EDIT.

package tests

import (
	"strconv"

	"github.com/yandex-cloud/ydb-go-sdk"
	"github.com/yandex-cloud/ydb-go-sdk/table"
)

var (
	_ = strconv.Itoa
	_ = ydb.StringValue
	_ = table.NewQueryParameters
)

func (c *Container) Scan(res *table.Result) (err error) {
	res.SeekItem("string")
	c.String = res.OUTF8()

	res.SeekItem("int_to_uint64")
	c.IntToUint64 = ydbConvU64ToI(res.Uint64())

	res.SeekItem("structs")
	n0 := res.ListIn()
	xs0 := make([]Foo, n0)
	for i0 := 0; i0 < n0; i0++ {
		res.ListItem(i0)
		var x0 Foo
		for i1, n1 := 0, res.StructIn(); i1 < n1; i1++ {
			switch res.StructField(i1) {
			case "id":
				x0.ID = res.OUTF8()
			case "ints":
				n2 := res.ListIn()
				xs1 := make([]int32, n2)
				for i2 := 0; i2 < n2; i2++ {
					res.ListItem(i2)
					var x1 int32
					x1 = res.Int32()
					xs1[i2] = x1
				}
				x0.Ints = xs1
				res.ListOut()
			}
		}
		res.StructOut()
		xs0[i0] = x0
	}
	c.Structs = xs0
	res.ListOut()

	res.SeekItem("bytes")
	c.Bytes = []byte(res.String())

	return res.Err()
}

func (c *Container) QueryParameters() *table.QueryParameters {
	var v0 ydb.Value
	{
		vp0 := ydb.UTF8Value(c.String)
		v0 = ydb.OptionalValue(vp0)
	}
	var v1 ydb.Value
	{
		vp0 := ydb.Uint64Value(ydbConvIToU64(c.IntToUint64))
		v1 = vp0
	}
	var v2 ydb.Value
	{
		var list0 ydb.Value
		vs0 := make([]ydb.Value, len(c.Structs))
		for i0, item0 := range c.Structs {
			var v3 ydb.Value
			{
				var v4 ydb.Value
				{
					vp0 := ydb.UTF8Value(item0.ID)
					v4 = ydb.OptionalValue(vp0)
				}
				var v5 ydb.Value
				{
					var list1 ydb.Value
					vs1 := make([]ydb.Value, len(item0.Ints))
					for i1, item1 := range item0.Ints {
						var v6 ydb.Value
						{
							vp0 := ydb.Int32Value(item1)
							v6 = vp0
						}
						vs1[i1] = v6
					}
					if len(vs1) == 0 {
						var t1 ydb.Type
						{
							tp0 := ydb.TypeInt32
							t1 = tp0
						}
						t0 := ydb.List(t1)
						list1 = ydb.ZeroValue(t0)
					} else {
						list1 = ydb.ListValue(vs1...)
					}
					v5 = list1
				}
				v3 = ydb.StructValue(
					ydb.StructFieldValue("id", v4),
					ydb.StructFieldValue("ints", v5),
				)
			}
			vs0[i0] = v3
		}
		if len(vs0) == 0 {
			var t1 ydb.Type
			{
				fs0 := make([]ydb.StructOption, 2)
				var t2 ydb.Type
				{
					tp0 := ydb.TypeUTF8
					t2 = ydb.Optional(tp0)
				}
				fs0[0] = ydb.StructField("id", t2)
				var t3 ydb.Type
				{
					var t5 ydb.Type
					{
						tp0 := ydb.TypeInt32
						t5 = tp0
					}
					t4 := ydb.List(t5)
					t3 = t4
				}
				fs0[1] = ydb.StructField("ints", t3)
				t1 = ydb.Struct(fs0...)
			}
			t0 := ydb.List(t1)
			list0 = ydb.ZeroValue(t0)
		} else {
			list0 = ydb.ListValue(vs0...)
		}
		v2 = list0
	}
	var v3 ydb.Value
	{
		vp0 := ydb.StringValue([]uint8(c.Bytes))
		v3 = vp0
	}
	return table.NewQueryParameters(
		table.ValueParam("$string", v0),
		table.ValueParam("$int_to_uint64", v1),
		table.ValueParam("$structs", v2),
		table.ValueParam("$bytes", v3),
	)
}

func (c *Container) StructValue() ydb.Value {
	var v0 ydb.Value
	{
		var v1 ydb.Value
		{
			vp0 := ydb.UTF8Value(c.String)
			v1 = ydb.OptionalValue(vp0)
		}
		var v2 ydb.Value
		{
			vp0 := ydb.Uint64Value(ydbConvIToU64(c.IntToUint64))
			v2 = vp0
		}
		var v3 ydb.Value
		{
			var list0 ydb.Value
			vs0 := make([]ydb.Value, len(c.Structs))
			for i0, item0 := range c.Structs {
				var v4 ydb.Value
				{
					var v5 ydb.Value
					{
						vp0 := ydb.UTF8Value(item0.ID)
						v5 = ydb.OptionalValue(vp0)
					}
					var v6 ydb.Value
					{
						var list1 ydb.Value
						vs1 := make([]ydb.Value, len(item0.Ints))
						for i1, item1 := range item0.Ints {
							var v7 ydb.Value
							{
								vp0 := ydb.Int32Value(item1)
								v7 = vp0
							}
							vs1[i1] = v7
						}
						if len(vs1) == 0 {
							var t1 ydb.Type
							{
								tp0 := ydb.TypeInt32
								t1 = tp0
							}
							t0 := ydb.List(t1)
							list1 = ydb.ZeroValue(t0)
						} else {
							list1 = ydb.ListValue(vs1...)
						}
						v6 = list1
					}
					v4 = ydb.StructValue(
						ydb.StructFieldValue("id", v5),
						ydb.StructFieldValue("ints", v6),
					)
				}
				vs0[i0] = v4
			}
			if len(vs0) == 0 {
				var t1 ydb.Type
				{
					fs0 := make([]ydb.StructOption, 2)
					var t2 ydb.Type
					{
						tp0 := ydb.TypeUTF8
						t2 = ydb.Optional(tp0)
					}
					fs0[0] = ydb.StructField("id", t2)
					var t3 ydb.Type
					{
						var t5 ydb.Type
						{
							tp0 := ydb.TypeInt32
							t5 = tp0
						}
						t4 := ydb.List(t5)
						t3 = t4
					}
					fs0[1] = ydb.StructField("ints", t3)
					t1 = ydb.Struct(fs0...)
				}
				t0 := ydb.List(t1)
				list0 = ydb.ZeroValue(t0)
			} else {
				list0 = ydb.ListValue(vs0...)
			}
			v3 = list0
		}
		var v4 ydb.Value
		{
			vp0 := ydb.StringValue([]uint8(c.Bytes))
			v4 = vp0
		}
		v0 = ydb.StructValue(
			ydb.StructFieldValue("string", v1),
			ydb.StructFieldValue("int_to_uint64", v2),
			ydb.StructFieldValue("structs", v3),
			ydb.StructFieldValue("bytes", v4),
		)
	}
	return v0
}

func (c *Container) StructType() ydb.Type {
	var t0 ydb.Type
	{
		fs0 := make([]ydb.StructOption, 4)
		var t1 ydb.Type
		{
			tp0 := ydb.TypeUTF8
			t1 = ydb.Optional(tp0)
		}
		fs0[0] = ydb.StructField("string", t1)
		var t2 ydb.Type
		{
			tp0 := ydb.TypeUint64
			t2 = tp0
		}
		fs0[1] = ydb.StructField("int_to_uint64", t2)
		var t3 ydb.Type
		{
			var t5 ydb.Type
			{
				fs1 := make([]ydb.StructOption, 2)
				var t6 ydb.Type
				{
					tp0 := ydb.TypeUTF8
					t6 = ydb.Optional(tp0)
				}
				fs1[0] = ydb.StructField("id", t6)
				var t7 ydb.Type
				{
					var t9 ydb.Type
					{
						tp0 := ydb.TypeInt32
						t9 = tp0
					}
					t8 := ydb.List(t9)
					t7 = t8
				}
				fs1[1] = ydb.StructField("ints", t7)
				t5 = ydb.Struct(fs1...)
			}
			t4 := ydb.List(t5)
			t3 = t4
		}
		fs0[2] = ydb.StructField("structs", t3)
		var t4 ydb.Type
		{
			tp0 := ydb.TypeString
			t4 = tp0
		}
		fs0[3] = ydb.StructField("bytes", t4)
		t0 = ydb.Struct(fs0...)
	}
	return t0
}

func (f *Foo) Scan(res *table.Result) (err error) {
	res.SeekItem("id")
	f.ID = res.OUTF8()

	res.SeekItem("ints")
	n0 := res.ListIn()
	xs0 := make([]int32, n0)
	for i0 := 0; i0 < n0; i0++ {
		res.ListItem(i0)
		var x0 int32
		x0 = res.Int32()
		xs0[i0] = x0
	}
	f.Ints = xs0
	res.ListOut()

	return res.Err()
}

func (f *Foo) QueryParameters() *table.QueryParameters {
	var v0 ydb.Value
	{
		vp0 := ydb.UTF8Value(f.ID)
		v0 = ydb.OptionalValue(vp0)
	}
	var v1 ydb.Value
	{
		var list0 ydb.Value
		vs0 := make([]ydb.Value, len(f.Ints))
		for i0, item0 := range f.Ints {
			var v2 ydb.Value
			{
				vp0 := ydb.Int32Value(item0)
				v2 = vp0
			}
			vs0[i0] = v2
		}
		if len(vs0) == 0 {
			var t1 ydb.Type
			{
				tp0 := ydb.TypeInt32
				t1 = tp0
			}
			t0 := ydb.List(t1)
			list0 = ydb.ZeroValue(t0)
		} else {
			list0 = ydb.ListValue(vs0...)
		}
		v1 = list0
	}
	return table.NewQueryParameters(
		table.ValueParam("$id", v0),
		table.ValueParam("$ints", v1),
	)
}

func (f *Foo) StructValue() ydb.Value {
	var v0 ydb.Value
	{
		var v1 ydb.Value
		{
			vp0 := ydb.UTF8Value(f.ID)
			v1 = ydb.OptionalValue(vp0)
		}
		var v2 ydb.Value
		{
			var list0 ydb.Value
			vs0 := make([]ydb.Value, len(f.Ints))
			for i0, item0 := range f.Ints {
				var v3 ydb.Value
				{
					vp0 := ydb.Int32Value(item0)
					v3 = vp0
				}
				vs0[i0] = v3
			}
			if len(vs0) == 0 {
				var t1 ydb.Type
				{
					tp0 := ydb.TypeInt32
					t1 = tp0
				}
				t0 := ydb.List(t1)
				list0 = ydb.ZeroValue(t0)
			} else {
				list0 = ydb.ListValue(vs0...)
			}
			v2 = list0
		}
		v0 = ydb.StructValue(
			ydb.StructFieldValue("id", v1),
			ydb.StructFieldValue("ints", v2),
		)
	}
	return v0
}

func (f *Foo) StructType() ydb.Type {
	var t0 ydb.Type
	{
		fs0 := make([]ydb.StructOption, 2)
		var t1 ydb.Type
		{
			tp0 := ydb.TypeUTF8
			t1 = ydb.Optional(tp0)
		}
		fs0[0] = ydb.StructField("id", t1)
		var t2 ydb.Type
		{
			var t4 ydb.Type
			{
				tp0 := ydb.TypeInt32
				t4 = tp0
			}
			t3 := ydb.List(t4)
			t2 = t3
		}
		fs0[1] = ydb.StructField("ints", t2)
		t0 = ydb.Struct(fs0...)
	}
	return t0
}

func (bs *Bar) Scan(res *table.Result) (err error) {
	for res.NextRow() {
		var x0 [][]string
		n0 := res.ListIn()
		xs0 := make([][]string, n0)
		for i0 := 0; i0 < n0; i0++ {
			res.ListItem(i0)
			var x1 []string
			n1 := res.ListIn()
			xs1 := make([]string, n1)
			for i1 := 0; i1 < n1; i1++ {
				res.ListItem(i1)
				var x2 string
				x2 = res.UTF8()
				xs1[i1] = x2
			}
			x1 = xs1
			res.ListOut()
			xs0[i0] = x1
		}
		x0 = xs0
		res.ListOut()
		if res.Err() == nil {
			*bs = append(*bs, x0)
		}
	}
	return res.Err()
}

func (Bar) ListType() ydb.Type {
	var t1 ydb.Type
	{
		var t3 ydb.Type
		{
			var t5 ydb.Type
			{
				tp0 := ydb.TypeUTF8
				t5 = tp0
			}
			t4 := ydb.List(t5)
			t3 = t4
		}
		t2 := ydb.List(t3)
		t1 = t2
	}
	t0 := ydb.List(t1)
	return t0
}

func (bs Bar) ListValue() ydb.Value {
	var list0 ydb.Value
	vs0 := make([]ydb.Value, len(bs))
	for i0, item0 := range bs {
		var v0 ydb.Value
		{
			var list1 ydb.Value
			vs1 := make([]ydb.Value, len(item0))
			for i1, item1 := range item0 {
				var v1 ydb.Value
				{
					var list2 ydb.Value
					vs2 := make([]ydb.Value, len(item1))
					for i2, item2 := range item1 {
						var v2 ydb.Value
						{
							vp0 := ydb.UTF8Value(item2)
							v2 = vp0
						}
						vs2[i2] = v2
					}
					if len(vs2) == 0 {
						var t1 ydb.Type
						{
							tp0 := ydb.TypeUTF8
							t1 = tp0
						}
						t0 := ydb.List(t1)
						list2 = ydb.ZeroValue(t0)
					} else {
						list2 = ydb.ListValue(vs2...)
					}
					v1 = list2
				}
				vs1[i1] = v1
			}
			if len(vs1) == 0 {
				var t1 ydb.Type
				{
					var t3 ydb.Type
					{
						tp0 := ydb.TypeUTF8
						t3 = tp0
					}
					t2 := ydb.List(t3)
					t1 = t2
				}
				t0 := ydb.List(t1)
				list1 = ydb.ZeroValue(t0)
			} else {
				list1 = ydb.ListValue(vs1...)
			}
			v0 = list1
		}
		vs0[i0] = v0
	}
	if len(vs0) == 0 {
		var t1 ydb.Type
		{
			var t3 ydb.Type
			{
				var t5 ydb.Type
				{
					tp0 := ydb.TypeUTF8
					t5 = tp0
				}
				t4 := ydb.List(t5)
				t3 = t4
			}
			t2 := ydb.List(t3)
			t1 = t2
		}
		t0 := ydb.List(t1)
		list0 = ydb.ZeroValue(t0)
	} else {
		list0 = ydb.ListValue(vs0...)
	}
	return list0
}

func ydbConvIToU64(x int) uint64 { 
	if x < 0 {
		panic("ydbgen: convassert: conversion of negative int to uint64")
	}
	return uint64(x)
}

func ydbConvU64ToI(x uint64) int { 
	const (
		bits = 32 << (^uint(0) >> 63)
		mask = (1 << (bits - 1)) - 1
	)
	abs := uint64(x)
	if abs&mask != abs {
		panic(
			"ydbgen: convassert: " + strconv.FormatUint(uint64(x), 10) +
				" (type uint64) overflows int",
		)
	}
	return int(x)
}

