// Code generated by ydbgen; DO NOT EDIT.

package main

import (
	"strconv"

	"github.com/yandex-cloud/ydb-go-sdk"
	"github.com/yandex-cloud/ydb-go-sdk/table"
)

var (
	_ = strconv.Itoa
	_ = ydb.StringValue
	_ = table.NewQueryParameters
)

func (u *User) Scan(res *table.Result) (err error) {
	res.SeekItem("id")
	u.ID = res.OUint64()

	res.SeekItem("username")
	u.Username = res.OUTF8()

	res.SeekItem("mode")
	u.Mode = ydbConvU64ToU8(res.OUint64())

	res.SeekItem("magic")
	u.Magic = uint(res.OUint32())

	res.SeekItem("score")
	res.Unwrap()
	if !res.IsNull() {
		x := res.Int64()
		u.Score.Set(x)
	}

	res.SeekItem("updated")
	res.Unwrap()
	if !res.IsNull() {
		x := res.Timestamp()
		err := (*ydb.Time)(&u.Updated).FromTimestamp(x)
		if err != nil {
			panic("ydbgen: date type conversion failed: " + err.Error())
		}
	}

	return res.Err()
}

func (u *User) QueryParameters() *table.QueryParameters {
	var ScoreValue ydb.Value
	{
		x, ok := u.Score.Get()
		if ok {
			ScoreValue = ydb.OptionalValue(ydb.Int64Value(x))
		} else {
			ScoreValue = ydb.NullValue(ydb.TypeInt64)
		}
	}
	var UpdatedValue ydb.Value
	{
		var x uint64
		ok := !u.Updated.IsZero()
		if ok {
			x = ydb.Time(u.Updated).Timestamp()
		}
		if ok {
			UpdatedValue = ydb.OptionalValue(ydb.TimestampValue(x))
		} else {
			UpdatedValue = ydb.NullValue(ydb.TypeTimestamp)
		}
	}
	return table.NewQueryParameters(
		table.ValueParam("$id", ydb.OptionalValue(ydb.Uint64Value(u.ID))),
		table.ValueParam("$username", ydb.OptionalValue(ydb.UTF8Value(u.Username))),
		table.ValueParam("$mode", ydb.OptionalValue(ydb.Uint64Value(uint64(u.Mode)))),
		table.ValueParam("$magic", ydb.OptionalValue(ydb.Uint32Value(uint32(u.Magic)))),
		table.ValueParam("$score", ScoreValue),
		table.ValueParam("$updated", UpdatedValue),
	)
}

func (u *User) StructValue() ydb.Value {
	var ScoreValue ydb.Value
	{
		x, ok := u.Score.Get()
		if ok {
			ScoreValue = ydb.OptionalValue(ydb.Int64Value(x))
		} else {
			ScoreValue = ydb.NullValue(ydb.TypeInt64)
		}
	}
	var UpdatedValue ydb.Value
	{
		var x uint64
		ok := !u.Updated.IsZero()
		if ok {
			x = ydb.Time(u.Updated).Timestamp()
		}
		if ok {
			UpdatedValue = ydb.OptionalValue(ydb.TimestampValue(x))
		} else {
			UpdatedValue = ydb.NullValue(ydb.TypeTimestamp)
		}
	}
	val := ydb.StructValue(
		ydb.StructFieldValue("id", ydb.OptionalValue(ydb.Uint64Value(u.ID))),
		ydb.StructFieldValue("username", ydb.OptionalValue(ydb.UTF8Value(u.Username))),
		ydb.StructFieldValue("mode", ydb.OptionalValue(ydb.Uint64Value(uint64(u.Mode)))),
		ydb.StructFieldValue("magic", ydb.OptionalValue(ydb.Uint32Value(uint32(u.Magic)))),
		ydb.StructFieldValue("score", ScoreValue),
		ydb.StructFieldValue("updated", UpdatedValue),
	)
	return val
}

func (u *User) StructType() ydb.Type {
	return ydb.Struct(
		ydb.StructField("id", ydb.Optional(ydb.TypeUint64)),
		ydb.StructField("username", ydb.Optional(ydb.TypeUTF8)),
		ydb.StructField("mode", ydb.Optional(ydb.TypeUint64)),
		ydb.StructField("magic", ydb.Optional(ydb.TypeUint32)),
		ydb.StructField("score", ydb.Optional(ydb.TypeInt64)),
		ydb.StructField("updated", ydb.Optional(ydb.TypeTimestamp)),
	)
}

func (us *Users) Scan(res *table.Result) (err error) {
	for res.NextRow() {
		var x User

		res.SeekItem("id")
		x.ID = res.OUint64()

		res.SeekItem("username")
		x.Username = res.OUTF8()

		res.SeekItem("mode")
		x.Mode = ydbConvU64ToU8(res.OUint64())

		res.SeekItem("magic")
		x.Magic = uint(res.OUint32())

		res.SeekItem("score")
		res.Unwrap()
		if !res.IsNull() {
			x0 := res.Int64()
			x.Score.Set(x0)
		}

		res.SeekItem("updated")
		res.Unwrap()
		if !res.IsNull() {
			x0 := res.Timestamp()
			err := (*ydb.Time)(&x.Updated).FromTimestamp(x0)
			if err != nil {
				panic("ydbgen: date type conversion failed: " + err.Error())
			}
		}

		*us = append(*us, x)
	}
	return res.Err()
}

func (us Users) ListValue() ydb.Value {
	values := make([]ydb.Value, len(us))
	for i, u := range us {
		var ScoreValue ydb.Value
		{
			x, ok := u.Score.Get()
			if ok {
				ScoreValue = ydb.OptionalValue(ydb.Int64Value(x))
			} else {
				ScoreValue = ydb.NullValue(ydb.TypeInt64)
			}
		}
		var UpdatedValue ydb.Value
		{
			var x uint64
			ok := !u.Updated.IsZero()
			if ok {
				x = ydb.Time(u.Updated).Timestamp()
			}
			if ok {
				UpdatedValue = ydb.OptionalValue(ydb.TimestampValue(x))
			} else {
				UpdatedValue = ydb.NullValue(ydb.TypeTimestamp)
			}
		}
		values[i] = ydb.StructValue(
			ydb.StructFieldValue("id", ydb.OptionalValue(ydb.Uint64Value(u.ID))),
			ydb.StructFieldValue("username", ydb.OptionalValue(ydb.UTF8Value(u.Username))),
			ydb.StructFieldValue("mode", ydb.OptionalValue(ydb.Uint64Value(uint64(u.Mode)))),
			ydb.StructFieldValue("magic", ydb.OptionalValue(ydb.Uint32Value(uint32(u.Magic)))),
			ydb.StructFieldValue("score", ScoreValue),
			ydb.StructFieldValue("updated", UpdatedValue),
		)
	}
	if len(values) == 0 {
		return ydb.ZeroValue(
			ydb.List(ydb.Struct(
				ydb.StructField("id", ydb.Optional(ydb.TypeUint64)),
				ydb.StructField("username", ydb.Optional(ydb.TypeUTF8)),
				ydb.StructField("mode", ydb.Optional(ydb.TypeUint64)),
				ydb.StructField("magic", ydb.Optional(ydb.TypeUint32)),
				ydb.StructField("score", ydb.Optional(ydb.TypeInt64)),
				ydb.StructField("updated", ydb.Optional(ydb.TypeTimestamp)),
			)),
		)
	}
	return ydb.ListValue(values...)
}

func ydbConvU64ToU8(x uint64) uint8 {
	const (
		bits = 8
		mask = (1 << (bits)) - 1
	)
	abs := uint64(x)
	if abs&mask != abs {
		panic(
			"ydbgen: convassert: " + strconv.FormatUint(uint64(x), 10) +
				" (type uint64) overflows uint8",
		)
	}
	return uint8(x)
}
